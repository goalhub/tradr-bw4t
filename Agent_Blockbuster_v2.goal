init module {
	knowledge {

%% ---- General Knowledge ---------------------------------------------------------------------------		
		% A room is a place with exactly one neighbour, i.e., only way way to get to and from that place.
		room(PlaceID) :- zone(_,PlaceID,_,_,Neighbours), length(Neighbours,1).
		
		%Short reference to own block
		holding(BlockID,ColorID) :- me(Me), holding(Me, BlockID,ColorID).
		
		%Match formulation of goals with their beliefs
		holding(_,Agent, BlockID,ColorID,_) :- holding(Agent, BlockID,ColorID).				
		in(_,Agent,RoomID) :- in(Agent,RoomID).	
		
		%when holding a block you are also at a block.
		%This is so the goal in(),atBlock(),holding() can be completed altogether using the beliefbase
		atBlock(BlockID) :- holding(BlockID,_).


%% ---- Calculating distances------------------------------------------------------
		% Distance is the number of adjecent zones that have to be crossed to get to the location		
		  
		% distance to a room, and back to the frontdropzone.
		deliveryDistance(RoomID,Dist) :- at(MyLoc), findPath([MyLoc],RoomID,Dist1),findPath([RoomID],'FrontDropZone',Dist2),Dist is Dist1+Dist2.	
				
		%findPath(+Start,+Finish,-Distance) recursively broadens the search, and ends when the finish node is part of the list.
		findPath(Start,Finish, 0) :- memberchk(Finish,Start),!.
		findPath(Start,Finish, Distance) :- extendsearch(Start,[],NeighbourList),sort(NeighbourList,SortedNeighbourList), findPath(SortedNeighbourList, Finish, D),Distance is D+1.
		
		
		%alternative faster but less accurate option with eucledian distance:
		%findPath([Start|_],Finish,Distance) :- zone(_,Start,RX,RY,_), zone(_,Finish,MX,MY,_), Distance is sqrt((RX-MX)^2 + (RY-MY)^2).		
				
		% broadening the search with all neighbours of the Roomlist
        extendsearch([Room|Roomlist],OldNeigbourList,CompleteNeighbourList):- zone(_,Room,_,_,Neigbours),append(Neigbours,OldNeigbourList,NewNeighbourList),extendsearch(Roomlist,NewNeighbourList,CompleteNeighbourList).
		extendsearch([],CompleteNeighbourList,CompleteNeighbourList).
			
	}
	
	beliefs{
		remainingSequence([],[]). 
		roomGoalList([]).
		blockGoalList([]).
		sequence([]).
		nextColorInSequence([]).
		roomtimer([],0).
		%otherTaskDist(0).
	}	
	goals{
		sentLogs.
	}
				
	program {
		% Store map information, i.e., navigation points in agent's belief base.
		forall bel(percept(zone(ID, Name, X, Y, Neighbours))) do insert(zone(ID, Name, X, Y, Neighbours)).
		
		% Record current state of movement in belief base.
		forall bel(percept(state(State))) do insert(state(State)).

		% adopt the goal sequence as a goal
		forall bel(percept(sequence(T))) do adopt(sequence(T)).
			
		% insert current location
		forall bel(percept(at(X))) do insert(at(X)).
		
		%reduce search time by precalculating distances
		%forall bel((zone(_,A,_,_,_),zone(_,B,_,_,_),findPath([A],B,D))) do insert(path([A,B],D)).

		
	}
	actionspec {	
		% Actions are only executed if the precondition of that action holds.
		
		% The goTo action makes the agent move to a place (location) in the BW4T environment.
		% As long as the agent has not arrived at the place it is going to, it will be in "traveling" mode.
		goTo(Location) {
            pre { zone(_,Location,_,_,_), not(state(traveling))}
			post { state(traveling) }
		}
		
		% the robot must be in the samre room as the block is located and it must not be already traveling.
		goToBlock(BlockID) {
            pre { block(BlockID,_,RoomID),at(RoomID), not(state(traveling))}
			post { state(traveling) }
		}		
		
		% pickup can only be performed when a block is near. Postconditions are handled by the percepts from the environment.
		pickUp{
			pre{ atBlock(_), not(holding(_,_))}
			post{ true }
		}
		
		% putDown can only be performed when a block is held. Postconditions are handled by the percepts from the environment.
		putDown{
			pre{ holding(_,_) }
			post{ true }
		}
	}		
}


main module [exit=nogoals]{
	program{		

		% perform actions to achief goals
		
		% drop blocks				
		if bel(holding(BlockID,ColorID), block(BlockID, ColorID, RoomID)) then{
			% drop the block if its color is not needed.
			% Before dropping also check if an agent is in the dropzone with that color, because sometimes percepts travel faster than communication of delivery
			if bel(remainingSequence(TDL,_),not( memberchk(ColorID, TDL)),me(Me)) then putDown + delete(block(BlockID, ColorID, RoomID)) + print([Me, 'dropped a block']). %log(bb)+log(gb)+log(pb)+log(mb).			
			% drop the block if in the dropzone and the color is needed and get out.
			if bel(at('DropZone'), nextColorInSequence(ColorID),sequence(S),append(S,[ColorID],NewS)) then putDown + delete(block(BlockID, ColorID, RoomID)) + 
				delete(sequence(S)) + insert(sequence(NewS)) + allother.send(delivered(ColorID)) + adopt(at('FrontDropZone')).		
		}
		
		if a-goal(holding(Nval,Me,BlockID,ColorID,SeqID)), bel(me(Me),atBlock(BlockID),block(BlockID, ColorID, RoomID)) then pickUp + allother.send(not(block(BlockID, ColorID, RoomID))).
		if a-goal(atBlock(BlockID)) then goToBlock(BlockID).		
		if a-goal(at(PlaceID)) then goTo(PlaceID).  
		if a-goal(in(Nval,Me,RoomID)), bel(me(Me)) then goTo(RoomID).

		
			
	}
}


event module {
	program{
				
%		////////////////////////////////////
%		belief percepts from the environment
%		\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
		
		%keep track of the agent's state
		forall bel(percept(state(NewState)),state(State)) do delete(state(State)) + insert(state(NewState)). 		
		
		% Keep track of current room.
		forall bel(percept(in(RoomID)),me(Me))	do insert(in(Me,RoomID)) + allother.send(:in(RoomID)).
		forall bel(percept(not(in(RoomID))),me(Me)) do delete(in(Me,RoomID)) + allother.send(:not(in(RoomID))).

		% Keep track of current place.
		forall bel(at(Placeid), percept(at(NewPlaceid))) do delete(at(Placeid)) + insert(at(NewPlaceid)).
		
		% Keep track of nearby blocks
		forall bel(percept(atBlock(BlockID)))	do insert(atBlock(BlockID)).
		forall bel(percept(not(atBlock(BlockID)))) do delete(atBlock(BlockID)).
		
		% Keep track of block colors and in which room in which the block is found
		forall bel(percept(color(BlockID, ColorID)), not(block(BlockID, ColorID,_)),me(Me),in(Me,RoomID)) do insert(block(BlockID, ColorID,RoomID)) + allother.send(:block(BlockID, ColorID,RoomID)).
		
		% Keep track of block holding
		forall bel(percept(holding(BlockID)), me(Me),block(BlockID,ColorID,_))	do insert(holding(Me, BlockID,ColorID)) + allother.send(:holding(BlockID,ColorID)).
		forall bel(percept(not(holding(BlockID))), me(Me),holding(Me,BlockID, ColorID)) do delete(holding(Me, BlockID,ColorID)) + allother.send(:not(holding(BlockID,ColorID))).	
							
				
%		////////////////////////////////////
%		Check old beliefs and memories with current percepts
%		\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\	
		
		%block not found
		forall bel(in(Me,RoomID), block(BlockID,ColorID,RoomID),not(percept(color(BlockID, ColorID))),not(holding(BlockID,ColorID)),me(Me)) do delete(block(BlockID,ColorID,RoomID)) + allother.send(not(block(BlockID,ColorID,RoomID))).

%		////////////////////////////////////////
%		make memories
%		\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

		%rooms that have been visited
		forall bel(in(Me,RoomID), not(visited(RoomID)),me(Me)) do insert(visited(RoomID)).
		
%		////////////////////////////////////////////
%		messages from other agents
%		\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

%		Beliefs
		
		%existing blocks
		forall bel(received(Sender, block(BlockID, ColorID,RoomID)), not(block(BlockID,ColorID,RoomID))) do insert(block(BlockID, ColorID,RoomID)).
		forall bel(received(Sender, not(block(BlockID, ColorID,RoomID))), block(BlockID,ColorID,RoomID), not(holding(BlockID,ColorID))) do delete(block(BlockID, ColorID,RoomID)).		
		
		%held blocks
		forall bel(received(Sender, holding(BlockID,ColorID)), not(holding(Sender,BlockID,ColorID))) do insert(holding(Sender,BlockID,ColorID)).
		forall bel(received(Sender, not(holding(BlockID,ColorID))), holding(Sender,BlockID,ColorID)) do delete(holding(Sender,BlockID,ColorID)).
		
		%in and visited rooms		
		forall bel(received(Sender, in(RoomID)), not(in(Sender,RoomID))) do {
			if true then insert(in(Sender,RoomID)).
			if bel(not(visited(RoomID))) then insert(visited(RoomID)). %make a memory
		}		
		forall bel(received(Sender, not(in(RoomID))), in(Sender,RoomID)) do delete(in(Sender,RoomID)).

		%learn about deliveries		
		forall bel(received(Sender, delivered(ColorID))) do {
			if bel(sequence(S),append(S,[ColorID],NewS)) then delete(sequence(S)) + insert(sequence(NewS)). %update sequence
			if bel(holding(Sender,BlockID,ColorID)) then delete(holding(Sender,BlockID,ColorID)).			%delete holding
		}

								
%		Goals		
		%holding blocks
		forall bel(received(Sender, imp(holding(NVal,BlockID,ColorID,SeqID)))) do adopt(holding(NVal,Sender,BlockID,ColorID,SeqID)).		
		forall bel(received(Sender, imp( not( holding(NVal,BlockID,ColorID,SeqID)))),me(Me)) do drop(holding(NVal,Sender,BlockID,ColorID,SeqID)).		
		
		%exploring rooms
		forall bel(received(Sender, imp(in(NVal,RoomID)))) do adopt(in(NVal,Sender,RoomID)).	
		forall bel(received(Sender, imp( not (in(NVal,RoomID))))) do drop(in(NVal,Sender,RoomID)).	
		
		forall bel(received(Sender, Message)) do delete(received(Sender, Message)).		


%		//////////////////////////////////////////
%		List what work needs to be done
%		\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

		% remainingSequence(ColorList,NumberList) contains two lists with the elements of the sequence that should be gathered
		% ColorList are the ColorIDs that should be gathered; NumberList are the corresponding SequenceIDs, so double colors can be distinguished   		
		%if bel(remainingSequence(C,N), colorList(Clist),numberList(Nlist)) then delete(remainingSequence(C,N)) + insert(remainingSequence(Clist,Nlist)).
		
		if goal(sequence(S)), bel(sequence(DoneList), append(DoneList,Clist,S), 
		length(S,Last),length(Clist,Nlength), Start is Last-Nlength, End is Last-1, numlist(Start, End, Nlist),remainingSequence(C,N)) 
		then delete(remainingSequence(C,N)) + insert(remainingSequence(Clist,Nlist)).
		
		if bel(remainingSequence([NextC|_],_), nextColorInSequence(C)) then delete(nextColorInSequence(C)) + insert(nextColorInSequence(NextC)).
		
		%Remove elements that are currently a goal to be delivered from remainingSequence.
		%The first element that matches SeqID and the corresponding Color is removed.
		forall goal(holding(NVal,Agent,BlockID,ColorID,SeqID)), bel(not(me(Agent))) do {
			if bel(remainingSequence(CList,NList), nth0(Indx,NList,SeqID,NewNList),nth0(Indx,CList,_,NewCList)) then delete(remainingSequence(CList,NList)) + insert(remainingSequence(NewCList,NewNList)).
		}
		
		%Remove elements that are currently held by an agent from remainingSequence.
		%The first element that matches ColorID and the corresponding SequenceID is removed.
		
		%is cut needed???
		forall bel(holding(Agent,BlockID,ColorID),not(me(Agent))) do {
			if bel(remainingSequence(CList,NList), nth0(Indx,CList,ColorID,NewCList),!,nth0(Indx,NList,_,NewNList)) then delete(remainingSequence(CList,NList)) + insert(remainingSequence(NewCList,NewNList)).
		}
		
%		//////////////////////////////////////////
%		check goals for duplication of effort
%		\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

		%holding goal		
		forall bel(me(Me), state(State)), goal(holding(NVal,Me, BlockID,ColorID,SeqID)) do {
			%drop when block doesn't exist
			forall bel(not(block(BlockID,_,_))) do drop(holding(NVal, Me,BlockID,ColorID,SeqID)) + allother.send(!not(holding(NVal,BlockID,ColorID,SeqID))) + delete(state(State)) + insert(state(arrived)). 
			%drop when other agent can perform the same goal faster
			forall goal(holding(PVal,Other,SomeBlockID,ColorID,SeqID)), bel(Other \= Me, NVal>PVal) do drop(holding(NVal, Me,BlockID,ColorID,SeqID)) + allother.send(!not(holding(NVal,BlockID,ColorID,SeqID))) + delete(state(State)) + insert(state(arrived)).
		}
		
		%drop duplicate room visit goals
		forall bel(me(Me),state(State)), goal(in(NVal,Me,RoomID)) do {
			forall goal(in(PVal,Other,RoomID)), bel(Other \= Me, NVal>PVal) do drop(in(NVal,Me,RoomID)) + allother.send(!not(in(NVal,RoomID))) + delete(state(State)) + insert(state(arrived)).
		}
		
		% don't go to dropzone if you don't hold the next required block
		forall bel(holding(Me, BlockID,ColorID),  not(nextColorInSequence(ColorID)), state(State), me(Me)) do {
			forall goal(at('DropZone')) do drop(at('DropZone')) + adopt(at('FrontDropZone'))+ delete(state(State)) + insert(state(arrived)).
			forall bel(at('DropZone')) do adopt(at('FrontDropZone'))+ delete(state(State)) + insert(state(arrived)).		%sometimes the line above isn't fast enough, so the bot needs to go out of the dropzone
		}
		
		
%		//////////////////////////////////////////
%		set new goals
%		\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
		
		%if not holding or having a goal to hold a block then select a block to deliver
		if bel(me(Me),not(holding(_,_))), not(goal(holding(_,Me,_,_,_);at(_);in(_,Me,_))) then nextBlockSelection.			
		
		%when holding a block then go to the dropzone, via frontdropzone
		if bel(holding(BlockID,ColorID), block(BlockID, ColorID, RoomID),me(Me)) then {
			%always go to frontdropzone with a block
			if not(goal(at('FrontDropZone'))), bel(at(PlaceID), PlaceID \= 'FrontDropZone', PlaceID \= 'DropZone') then adopt(at('FrontDropZone')).
			%go to dropzone if holding the next required color
			if bel(at('FrontDropZone'),nextColorInSequence(ColorID)) then adopt(at('DropZone')).	
		}	
		
		%if not holding a block, or going to a place then select a place to go
		if bel(me(Me),not(holding(_,_))), not(goal(at(_); atBlock(_); in(_,Me,_))) then nextRoomSelection.							

		
%		/////////////////////////////////////////////////
%		debugging
%  		\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

		%detect agents getting stuck in a room
		if bel(me(Me), in(Me,RoomID),roomtimer(TRoomID,I)) then {
			if bel(TRoomID == RoomID, Next is I+1) then delete(roomtimer(TRoomID,I)) + insert(roomtimer(RoomID,Next)).
			if bel(TRoomID \= RoomID) then delete(roomtimer(TRoomID,I)) + insert(roomtimer(RoomID,0)).
			if bel(I > 100, not(toolong)) then print([Me, 'I am stuck']) + insert(toolong) + bAnalyst.send(toolong).
		}
		
%		/////////////////////////////////////////////////
%		End of Life management
%  		\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
		%not part of functional program, but required to get statistics and do quick batchruns.	

					
		forall not(goal(sequence(S))) do {
			%send signal to the analyist that the agent is finished.	
			if true then bAnalyst.send(finished) + insert(sentLogs).
			
			%stop going to places
			forall goal(at(SomePlace)) do drop(at(SomePlace)).
			forall goal(in(NVal,Me,SomePlace)) do drop(in(NVal,Me,SomePlace)).
			forall goal(holding(NVal,Agent,BlockID,ColorID,SeqID)) do drop(holding(NVal,Agent,BlockID,ColorID,SeqID)).
		}
		
		
	}		
}

module nextRoomSelection{
	program [order=linearall]{		 
							
		%make a list of all rooms that are already a goal to be visited to exclude them from being selected.
		if bel(roomGoalList(RL)) then delete(roomGoalList(RL)) + insert(roomGoalList([])).	
							
		listall L <- goal(in(_,_,RoomID)) do {
			if bel(roomGoalList(RL)) then delete(roomGoalList(RL)) + insert(roomGoalList(L)).
		}				

%!!!!!!!!!!!!!!!!!!!!		
%NOTE: It would be nice if there was a variant on listall that returns [] instaid of fail when it cannot find matching goals (like findall does)
%now I still have to make extra predicates for this list. Otherwise I could have intergrated it elegantly in the line below.		
%!!!!!!!!!!!!!!!!!!!!		

		
		%select the closest unexplored room and set a goal to visit the room.
		if bel(me(Me),at(MyLoc),roomGoalList(RL),																							%get unavailable rooms
			findall([D,RoomID] , (room(RoomID),not(visited(RoomID)),not(memberchk(RoomID,RL)),RoomID\='DropZone',findPath([MyLoc],RoomID,D)) , L),	%find all available rooms and their distance
			sort(L,RoomList), [[Dist,OptiRoom]|_] = RoomList, random(R), NVal is R+Dist) 									%sort rooms for the closest distance, this distance (+ random) is the negotiation value
		then adopt(in(NVal,Me,OptiRoom)) + allother.send(!in(NVal,OptiRoom)).												%adopt and communicate goal to explore the closest room
		
		%go to frontdropzone if no room was selected			
		if not(goal(in(NVal,Me,OptiRoom))), bel(me(Me),not(at('FrontDropZone'))) then adopt(at('FrontDropZone')).				
		
	}
}

module nextBlockSelection{	
	program [order=linearall]{		

		%blockGoalList is a list of all blocks that will be used in the future
		if bel(blockGoalList(BL)) then delete(blockGoalList(BL)) + insert(blockGoalList([])).							
		
		% Add every block that is a goal to the blockGoalList
		listall L <- goal(holding(_,_,BlockID,_,_)) do {
			if bel(blockGoalList(BL)) then delete(blockGoalList(BL)) + insert(blockGoalList(L)).							
		}
		
		%bid, even if having another task first
		%if bel(otherTaskDist(X)) then delete(otherTaskDist(X)) + insert(otherTaskDist(0)).
		%if goal(in(_,Me,RoomID)), bel(at(MyLoc), findPath([MyLoc],RoomID,Dist)) then delete(otherTaskDist(0)) + insert(otherTaskDist(Dist)).
 		
		%select the closest available block of the required color and set a goal to get to and hold the block
		if bel(me(Me), blockGoalList(BlockGoalList), remainingSequence([ColorID|_],[SeqID|_]), 																	%get the required block color and unavailable blocks
			findall([D,SomeBlockID], (block(SomeBlockID,ColorID, SomeRoomID),not(memberchk(SomeBlockID, BlockGoalList)), deliveryDistance(SomeRoomID,D)),L),			%find all available blocks and their distance 
			sort(L,BlockList), [[Dist,OptiBlockID]|_] = BlockList,	block(OptiBlockID, ColorID, RoomID), random(R), NVal is Dist + R) 							%sort blocks for the closest distance, this distance (+ random) is the negotiation value
			then adopt(at(RoomID),atBlock(OptiBlockID), holding(NVal, Me,OptiBlockID,ColorID,SeqID)) + allother.send(!holding(NVal, OptiBlockID,ColorID,SeqID)).	%adopt and communicate goal to get the closest block
	}
}
	
