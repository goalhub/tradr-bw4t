init module {
	knowledge {

%% ---- General Knowledge ---------------------------------------------------------------------------		
		% A room is a place with exactly one neighbour, i.e., only way way to get to and from that place.
		room(PlaceID) :- zone(_,PlaceID,_,_,Neighbours), length(Neighbours,1).
		
		%Short reference to own block
		holding(BlockID,ColorID) :- me(Me), holding(Me, BlockID,ColorID).
		
		%Match formulation of goals with their beliefs
		holding(_,Agent, BlockID,ColorID,_) :- holding(Agent, BlockID,ColorID).				
		in(_,Agent,RoomID) :- in(Agent,RoomID).	
		
		%when holding a block you are also at a block.
		%This is so the goal in(),atBlock(),holding() can be completed altogether using the beliefbase
		atBlock(BlockID) :- holding(BlockID,_).


%% ---- Calculating distances------------------------------------------------------
		% Distance is the number of adjecent zones that have to be crossed to get to the location		
		  
		% distance to a room, and back to the frontdropzone.
		deliveryDistance(RoomID,Dist) :- at(MyLoc), findPath([MyLoc],RoomID,Dist1),findPath([RoomID],'FrontDropZone',Dist2),Dist is Dist1+Dist2.	
				
		%findPath(+Start,+Finish,-Distance) recursively broadens the search, and ends when the finish node is part of the list.
		findPath(Start,Finish, 0) :- memberchk(Finish,Start),!.
		findPath(Start,Finish, Distance) :- extendsearch(Start,[],NeighbourList),sort(NeighbourList,SortedNeighbourList), findPath(SortedNeighbourList, Finish, D),Distance is D+1.
		
		%use database instead
		%findPath([Start],Finish, Distance) :- path(Start,Finish,Distance).
				
		%alternative faster but less accurate option with eucledian distance:
		%findPath([Start|_],Finish,Distance) :- zone(_,Start,RX,RY,_), zone(_,Finish,MX,MY,_), Distance is sqrt((RX-MX)^2 + (RY-MY)^2).		
				
		% broadening the search with all neighbours of the Roomlist
        extendsearch([Room|Roomlist],OldNeigbourList,CompleteNeighbourList):- zone(_,Room,_,_,Neigbours),append(Neigbours,OldNeigbourList,NewNeighbourList),extendsearch(Roomlist,NewNeighbourList,CompleteNeighbourList).
		extendsearch([],CompleteNeighbourList,CompleteNeighbourList).
		
%% ----Speed improvements------------------------------------------------------------
		
		%remove numbered elements from NList, and remove the corresponding element from CList 
		reducelistn(CList,NList,[],CList,NList).
		reducelistn(CList,NList,[[_,SeqID]|T],NewCList,NewNList) :-	nth0(Indx,NList,SeqID,UNList),nth0(Indx,CList,_,UCList), reducelistn(UCList,UNList,T,NewCList,NewNList).	
		
		%remove colored elements from CList, and remove the corresponding index from NList
		reducelistc(CList,NList,[],CList,NList).
		reducelistc(CList,NList,[[_,ColorID]|T],NewCList,NewNList) :-	nth0(Indx,CList,ColorID,UCList),!,nth0(Indx,NList,_,UNList), reducelistc(UCList,UNList,T,NewCList,NewNList).				
	}
	
	beliefs{
		%#import "path_big24.pl" %using a database with precalculated path length is much faster in SWI-prolog, but very slow in GOAL.
		remainingSequence([],[]). 
		roomGoalList([]).
		blockGoalList([]).
		sequence([]).
		nextColorInSequence([]).
		
	}	
	goals{
		sentLogs.
	}
				
	program {
		% Store map information, i.e., navigation points in agent's belief base.
		forall bel(percept(zone(ID, Name, X, Y, Neighbours))) do insert(zone(ID, Name, X, Y, Neighbours)).
		
		% Record current state of movement in belief base.
		forall bel(percept(state(State))) do insert(state(State)).

		% adopt the goal sequence as a goal and tell it to the analyst
		forall bel(percept(sequence(T))) do adopt(sequence(T)) + bAnalyst.send(sequence(T)).
			
		% insert current location
		forall bel(percept(at(X))) do insert(at(X)).
		
		%go to a close random room first (only to prevent huge communication load at start), this is only faster when there are many agents				
		%if bel(room(RoomID), RoomID \= 'DropZone', findPath(['FrontDropZone'],RoomID,D),D<7,random(R),NVal is D+R,me(Me)) then adopt(in(NVal,Me,RoomID)) + allother.send(!in(NVal,RoomID)).
		
	}
	actionspec {	
		% Actions are only executed if the precondition of that action holds.
		
		% The goTo action makes the agent move to a place (location) in the BW4T environment.
		% As long as the agent has not arrived at the place it is going to, it will be in "traveling" mode.
		goTo(Location) {
            pre {zone(_,Location,_,_,_),not(state(traveling))} %
			post { state(traveling) }
		}
		
		% the robot must be in the samre room as the block is located and it must not be already traveling.
		goToBlock(BlockID) {
            pre { block(BlockID,_,RoomID),at(RoomID), not(state(traveling))}
			post { state(traveling) }
		}		
		
		% pickup can only be performed when a block is near. Postconditions are handled by the percepts from the environment.
		pickUp{
			pre{ atBlock(_), not(holding(_,_))}
			post{ true }
		}
		
		% putDown can only be performed when a block is held. Postconditions are handled by the percepts from the environment.
		putDown{
			pre{ holding(_,_) }
			post{ true }
		}
	}		
}


main module [exit=nogoals]{
	program{		

		% perform actions to achief goals
		
		% drop blocks				
		if bel(holding(BlockID,ColorID), block(BlockID, ColorID, RoomID)) then{
			% drop the block if its color is not needed. (why can this happen?)			
			if bel(remainingSequence(TDL,_),not( memberchk(ColorID, TDL)),me(Me),in(Me,RoomID)) then putDown + delete(block(BlockID, ColorID, RoomID)) + print([Me, 'dropped a block']) + bAnalyst.send(dropped).% + log(bb)+log(gb)+log(pb)+log(mb).			
			% drop the block in the dropzone if the color is needed and get out.
			% Also add the color to the sequence and tell other agents about the delivery
			if bel(at('DropZone'), nextColorInSequence(ColorID),sequence(S),append(S,[ColorID],NewS),state(State)) then putDown + delete(block(BlockID, ColorID, RoomID)) + 
				delete(sequence(S)) + insert(sequence(NewS)) + allother.send(delivered(ColorID)) + adopt(at('FrontDropZone')) + delete(state(State)) + insert(state(arrived)).		
		}
		  		
		if a-goal(holding(Nval,Me,BlockID,ColorID,SeqID)), bel(me(Me),atBlock(BlockID),block(BlockID, ColorID, RoomID)) then pickUp + allother.send(not(block(BlockID, ColorID, RoomID))).
		if a-goal(atBlock(BlockID)), bel(state(State)) then goToBlock(BlockID) + delete(state(State)).		
		if a-goal(at(PlaceID)), bel(state(State)) then goTo(PlaceID) + delete(state(State)).
		if bel(me(Me),state(State)), goal(in(Nval,Me,RoomID)) then goTo(RoomID) + delete(state(State)).	
	}
}


event module {
	program{
				
%		////////////////////////////////////
%		belief percepts from the environment
%		\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
		
		%keep track of the agent's state
		forall bel(percept(state(NewState)),state(State)) do delete(state(State)) + insert(state(NewState)). 		
		
		% Keep track of current room.
		forall bel(percept(in(RoomID)),me(Me))	do insert(in(Me,RoomID)) + allother.send(:in(RoomID)).
		forall bel(percept(not(in(RoomID))),me(Me)) do delete(in(Me,RoomID)) + allother.send(:not(in(RoomID))).

		% Keep track of current place.
		forall bel(at(Placeid), percept(at(NewPlaceid))) do delete(at(Placeid)) + insert(at(NewPlaceid)).
		
		% Keep track of nearby blocks
		forall bel(percept(atBlock(BlockID)))	do insert(atBlock(BlockID)).
		forall bel(percept(not(atBlock(BlockID)))) do delete(atBlock(BlockID)).
		
		% Keep track of block colors and in which room in which the block is found
		forall bel(percept(color(BlockID, ColorID)), not(block(BlockID, ColorID,_)),me(Me),in(Me,RoomID)) do insert(block(BlockID, ColorID,RoomID)) + allother.send(:block(BlockID, ColorID,RoomID)).
		
		% Keep track of block holding
		forall bel(percept(holding(BlockID)), me(Me),block(BlockID,ColorID,_))	do insert(holding(Me, BlockID,ColorID)) + allother.send(:holding(BlockID,ColorID)).
		forall bel(percept(not(holding(BlockID))), me(Me),holding(Me,BlockID, ColorID)) do delete(holding(Me, BlockID,ColorID)) + allother.send(:not(holding(BlockID,ColorID))).	
							
				
%		////////////////////////////////////
%		Check old beliefs and memories with current percepts
%		\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\	
		
		%block not found
		forall bel(in(Me,RoomID), block(BlockID,ColorID,RoomID),not(percept(color(BlockID, ColorID))),not(holding(BlockID,ColorID)),me(Me)) do delete(block(BlockID,ColorID,RoomID)) + allother.send(not(block(BlockID,ColorID,RoomID))).

%		////////////////////////////////////////
%		make memories
%		\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

		%rooms that have been visited
		forall bel(in(Me,RoomID), not(visited(RoomID)),me(Me)) do insert(visited(RoomID)).
		
%		////////////////////////////////////////////
%		messages from other agents
%		\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

%		Beliefs
		
		%existing blocks
		forall bel(received(Sender, block(BlockID, ColorID,RoomID)), not(block(BlockID,ColorID,RoomID))) do insert(block(BlockID, ColorID,RoomID)).
		forall bel(received(Sender, not(block(BlockID, ColorID,RoomID))), block(BlockID,ColorID,RoomID), not(holding(BlockID,ColorID))) do delete(block(BlockID, ColorID,RoomID)).		
		
		%held blocks
		forall bel(received(Sender, holding(BlockID,ColorID)), not(holding(Sender,BlockID,ColorID))) do insert(holding(Sender,BlockID,ColorID)).
		forall bel(received(Sender, not(holding(BlockID,ColorID))), holding(Sender,BlockID,ColorID)) do delete(holding(Sender,BlockID,ColorID)).
		
		%in and visited rooms		
		forall bel(received(Sender, in(RoomID)), not(in(Sender,RoomID))) do {
			if true then insert(in(Sender,RoomID)).
			if bel(not(visited(RoomID))) then insert(visited(RoomID)). %make a memory
		}		
		forall bel(received(Sender, not(in(RoomID))), in(Sender,RoomID)) do delete(in(Sender,RoomID)).

		%learn about deliveries		
		forall bel(received(Sender, delivered(ColorID))) do {
			if bel(sequence(S),append(S,[ColorID],NewS)) then delete(sequence(S)) + insert(sequence(NewS)). %update sequence
			if bel(holding(Sender,BlockID,ColorID)) then delete(holding(Sender,BlockID,ColorID)).			%delete holding
		}

								
%		Goals		
		%holding blocks
		forall bel(received(Sender, imp(holding(NVal,BlockID,ColorID,SeqID)))) do adopt(holding(NVal,Sender,BlockID,ColorID,SeqID)).		
		forall bel(received(Sender, imp( not( holding(NVal,BlockID,ColorID,SeqID)))),me(Me)) do drop(holding(NVal,Sender,BlockID,ColorID,SeqID)).		
		
		
		%exploring rooms
		forall bel(received(Sender, imp(in(NVal,RoomID))))  do {
			%store all goals
			if true then adopt(in(NVal,Sender,RoomID)).
			%fast method: only store goals that can be excecuted. (the goals that are not stored will later be dropped by the agent anyway.)
			%if goal(in(PVal,Agent,RoomID)), bel(NVal<PVal) then adopt(in(NVal,Sender,RoomID)) + drop(in(PVal,Agent,RoomID)). %only adopt the lowest one!
			%if not(goal(in(_,_,RoomID))) then adopt(in(NVal,Sender,RoomID)).			
		}
		forall bel(received(Sender, imp( not (in(NVal,RoomID))))), goal(in(NVal,Sender,RoomID)) do drop(in(NVal,Sender,RoomID)).						
		
		forall bel(received(Sender, Message)) do delete(received(Sender, Message)).		


%		//////////////////////////////////////////
%		check goals for duplication of effort
%		\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

		%holding goal		
		forall bel(me(Me), state(State)), goal(holding(NVal,Me, BlockID,ColorID,SeqID)) do {
			%drop when block doesn't exist
			forall bel(not(block(BlockID,_,_))) do drop(holding(NVal, Me,BlockID,ColorID,SeqID)) + allother.send(!not(holding(NVal,BlockID,ColorID,SeqID))) + delete(state(State)) + insert(state(arrived)). 
			%drop when other agent can perform the same goal faster
			forall goal(holding(PVal,Other,SomeBlockID,ColorID,SeqID)), bel(Other \= Me, NVal>PVal) do drop(holding(NVal, Me,BlockID,ColorID,SeqID)) + allother.send(!not(holding(NVal,BlockID,ColorID,SeqID))) + delete(state(State)) + insert(state(arrived)).
		}
		
		%drop duplicate room visit goals
		forall bel(me(Me),state(State)), goal(in(NVal,Me,RoomID)) do {
			forall goal(in(PVal,Other,RoomID)), bel(Other \= Me, NVal>PVal) do drop(in(NVal,Me,RoomID)) + allother.send(!not(in(NVal,RoomID))) + delete(state(State)) + insert(state(arrived)).
		}

%		//////////////////////////////////////////
%		List what work needs to be done
%		\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

		% remainingSequence(ColorList,NumberList) contains two lists with the elements of the sequence that should be gathered
		% ColorList are the ColorIDs that should be gathered; NumberList are the corresponding SequenceIDs, so double colors can be distinguished   		
		
		if goal(sequence(S)), bel(sequence(DoneList),remainingSequence(C,N), append(DoneList,Clist,S), Clist \= C, 
		length(S,Last),length(Clist,Nlength), Start is Last-Nlength, End is Last-1, numlist(Start, End, Nlist)) 
		then delete(remainingSequence(C,N)) + insert(remainingSequence(Clist,Nlist)).
		
		%next color that must be delivered.		
		if bel(remainingSequence([NextC|_],_), nextColorInSequence(C)) then delete(nextColorInSequence(C)) + insert(nextColorInSequence(NextC)).	
		
		%Remove elements that are currently a goal to be delivered from remainingSequence.
		%The first element that matches SeqID and the corresponding Color is removed.
		%speed-tweak: used listall instead of forall so only a single delete/insert is made.
		listall L <- goal(holding(_,Agent,_,_,SeqID)), bel(not(me(Agent))) do {
			if bel(remainingSequence(CList,NList), reducelistn(CList,NList,L,NewCList,NewNList)) then delete(remainingSequence(CList,NList)) + insert(remainingSequence(NewCList,NewNList)).
		}
		
		%Remove elements that are currently held by an agent from remainingSequence.
		%The first element that matches ColorID and the corresponding SequenceID is removed.
		listall L <- bel(holding(Agent,_,ColorID),not(me(Agent))) do {
			if bel(remainingSequence(CList,NList), reducelistc(CList,NList,L,NewCList,NewNList)) then delete(remainingSequence(CList,NList)) + insert(remainingSequence(NewCList,NewNList)).
		}
		
		
%		//////////////////////////////////////////
%		set/update goals
%		\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

		forall bel(me(Me), state(State)), goal(holding(NVal,Me, BlockID,ColorID,SeqID)) do {
			%drop when color is no longer needed
			if bel(remainingSequence(TDL,_),not( memberchk(ColorID, TDL))) then drop(holding(NVal, Me,BlockID,ColorID,SeqID)) + allother.send(!not(holding(NVal,BlockID,ColorID,SeqID))) + delete(state(State)) + insert(state(arrived)) + print([Me,'dropped goal',ColorID]).
		}
		
		% don't go to or be in dropzone if you don't hold the next required block
		forall bel(holding(Me, BlockID,ColorID),  not(nextColorInSequence(ColorID)), state(State), me(Me)) do {
			forall goal(at('DropZone')) do drop(at('DropZone')) + adopt(at('FrontDropZone'))+ delete(state(State)) + insert(state(arrived)).
			forall bel(at('DropZone')) do adopt(at('FrontDropZone'))+ delete(state(State)) + insert(state(arrived)).
		}
		
		%for block priority strategy: drop exploration tasks when holding a block.
		%forall goal(in(NVal,Me,RoomID)), bel(me(Me),holding(Me, BlockID,ColorID)) do drop(in(NVal,Me,RoomID)) + allother.send(!not(in(NVal,RoomID))).
		
		%quickest strategy: no other task is initiated untill the current task is finished.
		%NOTE: the effectiveness of a strategy is very dependent on computational performance. e.g. if negotiations take too long on a slow pc then the result is not effective anymore		
		
		%current task priority: if not delivering a block or exploring then select a block to deliver
		if bel(me(Me),not(holding(_,_))), not(goal(holding(_,Me,_,_,_);at(_);in(_,Me,_))) then nextBlockSelection.
		
		%block delivery priority: if not delivering a block then select a block to deliver (also when exploring)
		%if bel(me(Me),not(holding(_,_))), not(goal(holding(_,Me,_,_,_);at(_))) then nextBlockSelection.  		
		
		%when holding a block then go to the dropzone, via frontdropzone
		if bel(holding(BlockID,ColorID), block(BlockID, ColorID, RoomID),me(Me)) then {
			%always go to frontdropzone with a block
			if not(goal(at('FrontDropZone'))), bel(at(PlaceID), PlaceID \= 'FrontDropZone', PlaceID \= 'DropZone') then adopt(at('FrontDropZone')).
			%go to dropzone if holding the next required color
			if bel(at('FrontDropZone'),nextColorInSequence(ColorID)) then adopt(at('DropZone')).	
		}	
		
		%if not holding a block, or going to a place then select a place to go
		if bel(me(Me),not(holding(_,_))), not(goal(at(_); atBlock(_); in(_,Me,_))) then nextRoomSelection.							


%		/////////////////////////////////////////////////
%		End of Life management
%  		\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
		%not part of functional program, but required to get statistics and do quick batchruns.	

					
		forall not(goal(sequence(S))) do {
			%send signal to the analyist that the agent is finished.	
			if true then bAnalyst.send(finished) + insert(sentLogs).
			
			%stop going to places
			forall goal(at(SomePlace)) do drop(at(SomePlace)).
			forall goal(in(NVal,Me,SomePlace)) do drop(in(NVal,Me,SomePlace)).
			forall goal(holding(NVal,Agent,BlockID,ColorID,SeqID)) do drop(holding(NVal,Agent,BlockID,ColorID,SeqID)).
		}
		
		
	}		
}

module nextRoomSelection{
	program [order=linearall]{		 
							
		%make a list of all rooms that are already a goal to be visited to exclude them from being selected.
		if bel(roomGoalList(RL)) then delete(roomGoalList(RL)) + insert(roomGoalList([])).	
							
		listall L <- goal(in(_,_,RoomID)) do {
			if bel(roomGoalList(RL)) then delete(roomGoalList(RL)) + insert(roomGoalList(L)).
		}				

%!!!!!!!!!!!!!!!!!!!!		
%NOTE: It would be nice if there was a variant on listall that returns [] instaid of fail when it cannot find matching goals (like findall does)
%now I still have to make extra predicates for this list. Otherwise I could have intergrated it elegantly in the line below.		
%!!!!!!!!!!!!!!!!!!!!		

		
		%select the closest unexplored room and set a goal to visit the room.
		if bel(me(Me),at(MyLoc),roomGoalList(RL),																							%get unavailable rooms
			findall((D,RoomID) , (room(RoomID),not(visited(RoomID)),not(memberchk(RoomID,RL)),RoomID\='DropZone',findPath([MyLoc],RoomID,D)) , L),	%find all available rooms and their distance
			sort(L,RoomList), [(Dist,OptiRoom)|_] = RoomList, random(R), NVal is R+Dist) 									%sort rooms for the closest distance, this distance (+ random) is the negotiation value
		then adopt(in(NVal,Me,OptiRoom)) + allother.send(!in(NVal,OptiRoom)).												%adopt and communicate goal to explore the closest room
		
		%go to frontdropzone if no room was selected			
		if not(goal(in(NVal,Me,OptiRoom))), bel(me(Me),not(at('FrontDropZone'))) then adopt(at('FrontDropZone')).				
		
	}
}

module nextBlockSelection{	
	program [order=linearall]{		

		%blockGoalList is a list of all blocks that will be used in the future
		if bel(blockGoalList(BL)) then delete(blockGoalList(BL)) + insert(blockGoalList([])).							
		
		% Add every block that is a goal to the blockGoalList
		listall L <- goal(holding(_,_,BlockID,_,_)) do {
			if bel(blockGoalList(BL)) then delete(blockGoalList(BL)) + insert(blockGoalList(L)).							
		}
 		
		%select the closest available block of the required color and set a goal to get to and hold the block
		if bel(me(Me), blockGoalList(BlockGoalList), remainingSequence([ColorID|_],[SeqID|_]),state(State),																%get the required block color and unavailable blocks
			findall((D,SomeBlockID), (block(SomeBlockID,ColorID, SomeRoomID),not(memberchk(SomeBlockID, BlockGoalList)), deliveryDistance(SomeRoomID,D)),L),			%find all available blocks and their distance 
			sort(L,BlockList), [(Dist,OptiBlockID)|_] = BlockList,	block(OptiBlockID, ColorID, RoomID), random(R), NVal is Dist + R) 							%sort blocks for the closest distance, this distance (+ random) is the negotiation value
			then adopt(at(RoomID),atBlock(OptiBlockID), holding(NVal, Me,OptiBlockID,ColorID,SeqID)) + allother.send(!holding(NVal, OptiBlockID,ColorID,SeqID))	%adopt and communicate goal to get the closest block
			+ delete(state(State)) + insert(state(arrived)).
	}
}
	
